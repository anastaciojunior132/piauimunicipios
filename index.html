<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Globo – PIAUÍ (Cesium)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Cesium CSS -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.120/Widgets/widgets.min.css"
    integrity="sha512-+dummy"
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />

  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    /* Painel de coordenadas (equivalente ao #coords do Leaflet) */
    #coords {
      position: absolute;
      bottom: 35px; /* acima da barra de escala do Cesium */
      left: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 13px;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
      line-height: 1.3;
      pointer-events: none;
    }
    /* Upload botão */
    #uploadBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 101;
      background: white;
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    #uploadInput { display:none; }

    /* Busca município */
    #searchMunicipio {
      position: absolute;
      top: 10px;
      left: 140px;
      z-index: 101;
      padding: 5px 20px;
      width: 220px;
      border: 1px solid #ccc;
      border-radius: 20px;
      font-size: 16px;
    }
    #listaMunicipios {
      position: absolute;
      top: 40px;
      left: 140px;
      z-index: 102;
      max-height: 220px;
      overflow-y: auto;
      width: 220px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      display: none;
      font-size: 14px;
    }
    #listaMunicipios div {
      padding: 4px 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    #listaMunicipios div:hover { background:#ddd; }

    /* Controle de camadas */
    #layersPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 101;
      background: rgba(255,255,255,0.95);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      max-width: 220px;
    }
    #layersPanel h4 {
      margin: 0 0 6px 0;
      font-size: 15px;
    }
    #layersPanel label {
      display:block;
      margin-bottom:4px;
      cursor:pointer;
    }
    #legend {
      margin-top:8px;
      border-top:1px solid #ccc;
      padding-top:6px;
      font-size:13px;
      line-height:1.2;
    }
    #legend .item {
      display:flex;
      align-items:center;
      margin-bottom:3px;
    }
    #legend .swatch {
      width:16px;
      height:16px;
      margin-right:6px;
      border:1px solid #666;
    }
    #legend small {
      display:block;
      margin-top:6px;
      color:#555;
      line-height:1.2;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- Painel coords -->
  <div id="coords">Lat: - , Lon: - <br>UTM: - , Fuso: -</div>

  <!-- Upload -->
  <button id="uploadBtn">Upload KML</button>
  <input type="file" id="uploadInput" accept=".kml,.kmz,.xml" multiple />

  <!-- Busca -->
  <input type="text" id="searchMunicipio" placeholder="Pesquisar município" />
  <div id="listaMunicipios"></div>

  <!-- Camadas -->
  <div id="layersPanel">
    <h4>Camadas</h4>
    <label><input type="checkbox" id="chkTerritorios" checked> Territórios</label>
    <label><input type="checkbox" id="chkMunicipios" checked> Municípios</label>
    <label><input type="checkbox" id="chkLitigio" checked> Litígio</label>
    <label><input type="checkbox" id="chkLinhaImperial" checked> Linha Imperial</label>
    <div id="legend"></div>
  </div>

  <!-- Cesium JS -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.120/Cesium/Cesium.js"
    integrity="sha512-+dummy"
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <!-- JSZip para KMZ (usaremos igual) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    /**********************************
     * 1. Inicialização do Cesium
     **********************************/
    window.CESIUM_BASE_URL = "https://cdnjs.cloudflare.com/ajax/libs/cesium/1.120/Cesium/";

    Cesium.Ion.defaultAccessToken = "COLOQUE_SEU_TOKEN_AQUI"; // <-- substitua

    const viewer = new Cesium.Viewer("cesiumContainer", {
      timeline: false,
      animation: false,
      shouldAnimate: false,
      baseLayerPicker: true,
      geocoder: true,
      homeButton: true,
      sceneModePicker: true,
      navigationHelpButton: false,
      fullscreenButton: true,
      selectionIndicator: true,
      infoBox: true
    });

    // Ativa barra de escala (desde versões recentes; fallback custom se necessário)
    if (viewer.extend && Cesium.viewerCesiumNavigationMixin) {
      // (Opcional: plugin; se quiser escala mais Leaflet-like podemos colocar depois)
    }

    /**********************************
     * 2. Painel de coordenadas
     **********************************/
    const coordsDiv = document.getElementById("coords");
    const scratch = new Cesium.Cartesian3();
    const scratchCarto = new Cesium.Cartographic();

    // Atualiza coord ao mover mouse
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function (movement) {
      const cartesian = viewer.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid, scratch);
      if (!Cesium.defined(cartesian)) {
        coordsDiv.innerHTML = "Lat: - , Lon: - <br>UTM: - , Fuso: -";
        return;
      }
      Cesium.Cartographic.fromCartesian(cartesian, viewer.scene.globe.ellipsoid, scratchCarto);
      const latDeg = Cesium.Math.toDegrees(scratchCarto.latitude);
      const lonDeg = Cesium.Math.toDegrees(scratchCarto.longitude);
      const latTxt = latDeg.toFixed(5);
      const lonTxt = lonDeg.toFixed(5);

      const utm = latLonToUTM(latDeg, lonDeg);
      coordsDiv.innerHTML = `Lat: ${latTxt}, Lon: ${lonTxt}<br>UTM: ${utm.easting}, ${utm.northing}<br>Fuso: ${utm.zone}${utm.hemisphere}`;
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    /**********************************
     * 3. Conversão Lat/Lon -> UTM
     *    (mesma lógica usada no Leaflet; acrescente hemisfério N/S)
     **********************************/
    function latLonToUTM(lat, lon) {
      const a = 6378137.0;
      const f = 1/298.257223563;
      const k0 = 0.9996;

      const zone = Math.floor((lon + 180) / 6) + 1;
      const lonOrigin = (zone - 1) * 6 - 180 + 3; // meridiano central
      const λ0 = lonOrigin * Math.PI/180;
      const φ = lat * Math.PI/180;
      const λ = lon * Math.PI/180;
      const e = Math.sqrt(f * (2 - f));
      const e2 = e*e;
      const ePrimeSq = e2 / (1 - e2);

      const sinφ = Math.sin(φ);
      const cosφ = Math.cos(φ);
      const tanφ = Math.tan(φ);

      const N = a / Math.sqrt(1 - e2 * sinφ*sinφ);
      const T = tanφ*tanφ;
      const C = ePrimeSq * cosφ*cosφ;
      const A = cosφ * (λ - λ0);

      const M = a * (
        (1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256) * φ
        - (3*e2/8 + 3*e2*e2/32 + 45*e2*e2*e2/1024) * Math.sin(2*φ)
        + (15*e2*e2/256 + 45*e2*e2*e2/1024) * Math.sin(4*φ)
        - (35*e2*e2*e2/3072) * Math.sin(6*φ)
      );

      let easting = k0 * N * (
        A +
        (1 - T + C) * Math.pow(A,3) / 6 +
        (5 - 18*T + T*T + 72*C - 58*ePrimeSq) * Math.pow(A,5) / 120
      ) + 500000.0;

      let northing = k0 * (
        M + N * tanφ * (
          A*A/2 +
          (5 - T + 9*C + 4*C*C) * Math.pow(A,4)/24 +
          (61 - 58*T + T*T + 600*C - 330*ePrimeSq) * Math.pow(A,6)/720
        )
      );

      let hemisphere = "N";
      if (lat < 0) {
        northing += 10000000.0; // 10,000,000 meter offset para hemisfério sul
        hemisphere = "S";
      }

      return {
        easting: easting.toFixed(2),
        northing: northing.toFixed(2),
        zone,
        hemisphere
      };
    }

    /**********************************
     * 4. Paleta e legenda de territórios
     **********************************/
    const territorioPalette = [
      "#1f78b4", "#e31a1c", "#33a02c", "#ff7f00",
      "#6a3d9a", "#b15928", "#a6cee3", "#b2df8a",
      "#fb9a99", "#fdbf6f"
    ];
    const territorioColors = [];
    let colorIndex = 0;
    function getColorForTerritorio(nome) {
      let terr = territorioColors.find(t => t.nome === nome);
      if (!terr) {
        terr = { nome, cor: territorioPalette[colorIndex % territorioPalette.length] };
        territorioColors.push(terr);
        colorIndex++;
        updateLegend(); // atualiza legenda quando surgir novo
      }
      return Cesium.Color.fromCssColorString(terr.cor).withAlpha(0.4);
    }

    function updateLegend() {
      const legendDiv = document.getElementById("legend");
      let html = "<b>Territórios</b><br>";
      territorioColors.forEach(t => {
        html += `<div class="item"><span class="swatch" style="background:${t.cor}"></span>${t.nome}</div>`;
      });
      html += `<small>Coordenação de Cartografia e Geoinformação<br>CCGEO/CIET/SEPLAN</small>`;
      legendDiv.innerHTML = html;
    }

    /**********************************
     * 5. Carregar camadas GeoJSON existentes
     **********************************/
    let territoriosDS, municipiosDS, litigioDS, linhaImperialDS;
    const municipiosIndex = []; // [{nome, entity}] para busca

    // Territórios
    Cesium.GeoJsonDataSource.load("territorios.geojson", {
      clampToGround: true
    }).then(ds => {
      territoriosDS = ds;
      viewer.dataSources.add(ds);
      // estilo por NM_TD
      ds.entities.values.forEach(ent => {
        const nome = ent.properties && ent.properties.NM_TD ? ent.properties.NM_TD.getValue() : "Território";
        ent.polygon && (ent.polygon.material = getColorForTerritorio(nome));
        ent.polygon && (ent.polygon.outline = true);
        ent.polygon && (ent.polygon.outlineColor = Cesium.Color.BLACK);
        ent.description = buildEntityDescription(ent);
      });
      updateLegend();
    });

    // Municípios
    Cesium.GeoJsonDataSource.load("municipios.geojson", {
      clampToGround: true
    }).then(ds => {
      municipiosDS = ds;
      viewer.dataSources.add(ds);
      ds.entities.values.forEach(ent => {
        if (ent.polygon) {
          ent.polygon.material = Cesium.Color.TRANSPARENT;
          ent.polygon.outline = true;
          ent.polygon.outlineColor = Cesium.Color.BLACK;
          ent.polygon.outlineWidth = 1.5;
        }
        const nome = ent.properties && ent.properties.NM_MUN ? ent.properties.NM_MUN.getValue() : null;
        if (nome) {
          municipiosIndex.push({ nome, entity: ent });
        }
        ent.description = buildEntityDescription(ent);
      });
    });

    // Litígio
    Cesium.GeoJsonDataSource.load("litigio.geojson", {
      clampToGround: true
    }).then(ds => {
      litigioDS = ds;
      viewer.dataSources.add(ds);
      styleLines(ds, Cesium.Color.RED);
    });

    // Linha Imperial
    Cesium.GeoJsonDataSource.load("linha_imperial.geojson", {
      clampToGround: true
    }).then(ds => {
      linhaImperialDS = ds;
      viewer.dataSources.add(ds);
      styleLines(ds, Cesium.Color.BLUE, true); // dashed?
    });

    function styleLines(ds, color, dashed=false) {
      ds.entities.values.forEach(ent => {
        if (ent.polyline) {
          ent.polyline.material = dashed
            ? new Cesium.PolylineDashMaterialProperty({ color })
            : color;
          ent.polyline.width = 2;
        }
        ent.description = buildEntityDescription(ent);
      });
    }

    /**********************************
     * 6. Geração de popup (description) com atributos
     **********************************/
    function buildEntityDescription(ent) {
      if (!ent.properties) return "Sem atributos.";
      const props = ent.properties.propertyNames;
      let html = "<b>Atributos:</b><br>";
      props.forEach(p => {
        const v = ent.properties[p].getValue();
        html += `<b>${p}:</b> ${v}<br>`;
      });
      // botão de download (implementaremos depois)
      html += `<br><button onclick="downloadEntityKML('${ent.id}')">Baixar KML desta feição</button>`;
      return html;
    }

    /**********************************
     * 7. Download KML de uma entidade (simplificado)
     *    Nota: gera KML com geometria aproximada; polilinha/polígono.
     **********************************/
    window.downloadEntityKML = function(entityId) {
      const ent = findEntityById(entityId);
      if (!ent) {
        alert("Entidade não encontrada.");
        return;
      }
      const kml = entityToKml(ent);
      const blob = new Blob([kml], { type:"application/vnd.google-earth.kml+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "feicao.kml";
      a.click();
      URL.revokeObjectURL(url);
    };

    function findEntityById(id) {
      for (const ds of [territoriosDS, municipiosDS, litigioDS, linhaImperialDS]) {
        if (ds) {
          const ent = ds.entities.getById(id);
          if (ent) return ent;
        }
      }
      // uploads
      for (const ds of uploadedDataSources) {
        const ent = ds.entities.getById(id);
        if (ent) return ent;
      }
      return null;
    }

    function entityToKml(ent) {
      // Extrai coords em graus decimais
      const positions = getEntityPositions(ent);
      const props = ent.properties ? ent.properties.propertyNames.map(p =>
        `<Data name="${xmlEsc(p)}"><value>${xmlEsc(ent.properties[p].getValue() ?? "")}</value></Data>`
      ).join("") : "";
      const extData = props ? `<ExtendedData>${props}</ExtendedData>` : "";
      let geomKml = "";
      if (ent.polygon) {
        geomKml = polygonPositionsToKml(positions);
      } else if (ent.polyline) {
        geomKml = linePositionsToKml(positions);
      } else if (ent.position) {
        const carto = Cesium.Cartographic.fromCartesian(ent.position.getValue(Cesium.JulianDate.now()));
        geomKml = pointToKml([Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude)]);
      }
      return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2"><Document><Placemark>${extData}${geomKml}</Placemark></Document></kml>`;
    }

    function getEntityPositions(ent) {
      const time = Cesium.JulianDate.now();
      if (ent.polygon && ent.polygon.hierarchy) {
        const h = ent.polygon.hierarchy.getValue(time);
        return Cesium.PolygonHierarchy.isPrototypeOf(h) ? h.positions : h.positions;
      } else if (ent.polyline && ent.polyline.positions) {
        return ent.polyline.positions.getValue(time);
      }
      return [];
    }

    function polygonPositionsToKml(positions) {
      const coordsStr = cartesianArrayToLonLatStr(positions);
      return `<Polygon><outerBoundaryIs><LinearRing><coordinates>${coordsStr}</coordinates></LinearRing></outerBoundaryIs></Polygon>`;
    }
    function linePositionsToKml(positions) {
      const coordsStr = cartesianArrayToLonLatStr(positions);
      return `<LineString><coordinates>${coordsStr}</coordinates></LineString>`;
    }
    function pointToKml(coord) {
      return `<Point><coordinates>${coord.join(",")}</coordinates></Point>`;
    }
    function cartesianArrayToLonLatStr(arr) {
      const ellipsoid = viewer.scene.globe.ellipsoid;
      return arr.map(c => {
        const carto = ellipsoid.cartesianToCartographic(c);
        const lon = Cesium.Math.toDegrees(carto.longitude);
        const lat = Cesium.Math.toDegrees(carto.latitude);
        return `${lon},${lat}`;
      }).join(" ");
    }
    function xmlEsc(v) {
      return String(v ?? "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&apos;");
    }

    /**********************************
     * 8. Upload múltiplo KML/KMZ
     **********************************/
    const uploadBtn = document.getElementById("uploadBtn");
    const uploadInput = document.getElementById("uploadInput");
    const uploadedDataSources = [];

    uploadBtn.addEventListener("click", () => uploadInput.click());
    uploadInput.addEventListener("change", async (evt) => {
      const files = evt.target.files;
      if (!files || !files.length) return;
      for (const file of files) {
        try {
          let kmlText;
          if (/\.kmz$/i.test(file.name)) {
            const arrayBuffer = await file.arrayBuffer();
            kmlText = await extractKmzKml(arrayBuffer);
          } else {
            kmlText = await file.text();
          }
          const blob = new Blob([kmlText], {type:"application/vnd.google-earth.kml+xml"});
          const url = URL.createObjectURL(blob);
          const ds = await Cesium.KmlDataSource.load(url, {
            camera: viewer.scene.camera,
            canvas: viewer.scene.canvas,
            clampToGround: true
          });
          uploadedDataSources.push(ds);
          viewer.dataSources.add(ds);
          viewer.flyTo(ds);
        } catch (err) {
          console.error(err);
          alert("Erro ao carregar arquivo: " + err.message);
        }
      }
      uploadInput.value = "";
    });

    async function extractKmzKml(arrayBuffer) {
      const zip = await JSZip.loadAsync(arrayBuffer);
      let kmlEntry = null;
      zip.forEach((path, entry) => {
        if (!kmlEntry && /\.kml$/i.test(path)) {
          kmlEntry = entry;
        }
      });
      if (!kmlEntry) throw new Error("KMZ não contém KML.");
      return await kmlEntry.async("text");
    }

    /**********************************
     * 9. Liga/Desliga camadas
     **********************************/
    document.getElementById("chkTerritorios").addEventListener("change", e => toggleDS(territoriosDS, e.target.checked));
    document.getElementById("chkMunicipios").addEventListener("change", e => toggleDS(municipiosDS, e.target.checked));
    document.getElementById("chkLitigio").addEventListener("change", e => toggleDS(litigioDS, e.target.checked));
    document.getElementById("chkLinhaImperial").addEventListener("change", e => toggleDS(linhaImperialDS, e.target.checked));

    function toggleDS(ds, visible) {
      if (!ds) return;
      ds.show = visible;
    }

    /**********************************
     * 10. Busca de municípios (versão simples)
     **********************************/
    const searchInput = document.getElementById("searchMunicipio");
    const listaMunicipios = document.getElementById("listaMunicipios");

    searchInput.addEventListener("input", () => {
      const termo = searchInput.value.trim().toLowerCase();
      listaMunicipios.innerHTML = "";
      if (!termo) {
        listaMunicipios.style.display = "none";
        return;
      }
      const resultados = municipiosIndex.filter(item => item.nome.toLowerCase().includes(termo));
      if (!resultados.length) {
        listaMunicipios.style.display = "none";
        return;
      }
      resultados.forEach(r => {
        const div = document.createElement("div");
        div.textContent = r.nome;
        div.addEventListener("click", () => {
          flyToEntity(r.entity);
          listaMunicipios.style.display = "none";
          searchInput.value = r.nome;
        });
        listaMunicipios.appendChild(div);
      });
      listaMunicipios.style.display = "block";
    });

    // Enter = busca exata
    searchInput.addEventListener("keypress", e => {
      if (e.key === "Enter") {
        const termo = searchInput.value.trim().toLowerCase();
        let achou = false;
        for (const r of municipiosIndex) {
          if (r.nome.toLowerCase() === termo) {
            flyToEntity(r.entity);
            achou = true;
            break;
          }
        }
        if (!achou) alert("Município não encontrado!");
        listaMunicipios.style.display = "none";
      }
    });

    // Fecha lista ao clicar fora
    document.addEventListener("click", (e) => {
      if (!searchInput.contains(e.target) && !listaMunicipios.contains(e.target)) {
        listaMunicipios.style.display = "none";
      }
    });

    function flyToEntity(ent) {
      viewer.flyTo(ent).then(() => {
        // abre popup
        viewer.selectedEntity = ent;
      });
    }

    /**********************************
     * Fim do script
     **********************************/
  </script>
</body>
</html>
